The root of that “unhandled errors in a TaskGroup (1 sub‑exception)” is simply that your client’s `MCPServerSse.connect()` is failing under the hood (most likely a connection/refused or path‐not‐found error) and AnyIO is wrapping it in a TaskGroup exception. You don’t see the real cause because it gets hidden by AnyIO’s TaskGroup. Here’s how to unmask it and fix it:

---

## 1. Diagnose the real error  
Wrap the connect call and print the underlying exception:

```python
async def _test_connect():
    server = MCPServerSse(get_server_params())
    try:
        await server.connect()
        await server.cleanup()
        return True
    except Exception as e:
        # Print the actual cause
        import traceback; traceback.print_exc()
        return False

print(asyncio.run(_test_connect()))
```

You’ll probably see a **connection refused** or **404 on /sse** in the stack trace.

---

## 2. Ensure client and server agree on your SSE endpoint  
By default FastMCP serves its SSE stream at `/sse` and messages on `/messages`. If you only pass `url="http://127.0.0.1:8000"` the client will try whatever its default path is (often `/events` or `/stream`). You need to be explicit:

```python
from swarms.tools.mcp_integration import MCPServerSseParams

def get_server_params():
    return MCPServerSseParams(
        url="http://127.0.0.1:8000",
        sse_path="/sse",              # <— tell it exactly where the SSE lives
        messages_path="/messages",    # <— if your server uses /messages for POSTs
        headers={
            "Content-Type": "application/json",
            "Accept": "text/event-stream",
        },
        timeout=15.0,
        sse_read_timeout=60.0,
        require_session_id=False,     # match your server’s require_session_id
    )
```

---

## 3. Don’t manually call `MCPServerSse` unless you need to  
Your `test_server_connection()` can more reliably just do a raw HTTP(S) health‑check:

```python
def test_server_connection():
    health_url = get_server_params().url + get_server_params().sse_path
    try:
        r = httpx.get(health_url,
                      headers={"Accept":"text/event-stream"},
                      timeout=5.0)
        if r.status_code == 200:
            logger.info("✅ SSE endpoint is up")
            return True
        else:
            logger.error(f"❌ Unexpected status {r.status_code}")
            return False
    except Exception as e:
        logger.error(f"❌ Connection to SSE endpoint failed: {e}")
        return False
```

That way you see immediately if the server is refusing connections or returning 404.

---

## 4. Align your Agent configuration  
Once you’ve verified the raw GET to `http://127.0.0.1:8000/sse` is 200, your Agent should work with exactly the same params:

```python
math_agent = Agent(
    agent_name="Math Assistant",
    agent_description="Friendly math calculator",
    system_prompt=MATH_AGENT_PROMPT,
    max_loops=1,
    model_name="gpt-3.5-turbo",
    verbose=True,
    mcp_servers=[ get_server_params() ]
)
```

Now when you do `math_agent.run("add 3 and 4")`, the SSE handshake will succeed and you’ll no longer see that TaskGroup error.

---

### TL;DR
1. **Print the real exception** behind the TaskGroup to see “connection refused” or “404.”  
2. **Explicitly set** `sse_path="/sse"` (and `messages_path`) in `MCPServerSseParams`.  
3. **Health‑check** with a simple `httpx.get("…/sse")` instead of `server.connect()`.  
4. Pass those same params straight into your `Agent`.  

Once your client is pointing at the exact SSE URL your FastMCP server is serving, the Agent will connect cleanly and you’ll be back to doing math instead of wrestling TaskGroup errors.